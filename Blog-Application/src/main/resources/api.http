### Authenticate as admin
POST http://localhost:8080/api/v1/uaa/login
Content-Type: application/json

{
  "username": "admin",
  "password": "admin"
}

> {% client.global.set("admin_token", response.body.access_token); %}

### Signup a user
POST http://localhost:8080/api/v1/uaa/signup
Content-Type: application/json

{
  "username": "john",
  "password": "123",
  "firstname": "John",
  "lastname": "Doe",
  "email": "john.doe@miu.edu"
}

### Authenticate as user
POST http://localhost:8080/api/v1/uaa/login
Content-Type: application/json

{
  "username": "john",
  "password": "123"
}

> {% client.global.set("token", response.body.access_token); %}

### Create post
POST http://localhost:8080/api/v1/posts/
Authorization: Bearer {{token}}
Content-Type: application/json

{
    "title": "How to scale Microservices with Message Queues, Spring Boot, and Kubernetes",
    "body": "When you design and build applications at scale, you deal with two significant challenges: scalability and robustness. You should design your service so that even if it is subject to intermittent heavy loads, it continues to operate reliably. Take the Apple Store as an example. Every year millions of Apple customers preregister to buy a new iPhone. That’s millions of people all buying an item at the same time. If you were to picture the Apple store’s traffic as requests per second over time, this is what the graph could look like: "
}